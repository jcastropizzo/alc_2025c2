# -*- coding: utf-8 -*-
"""Copy of alc.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CuropEpc_S_GrgSgv1zC3fAyXuvpqPbB
"""

import numpy as np
import math #para sqrt en labo8

def esCuadrada(A):
  return A.shape[0] == A.shape[1]

def triangSup(A):
  U = A.copy()
  for i in range(0,U.shape[0]):
    for j in range(0, U.shape[1]):
      if(i>=j):
        U[i,j] = 0
  return U

def triangInf(A):
  L = A.copy()
  for i in range(0,L.shape[0]):
    for j in range(0, L.shape[1]):
      if(i<=j):
        L[i,j] = 0
  return L

def diagonal(A):
  D = A.copy()
  for i in range(0,D.shape[0]):
    for j in range(0, D.shape[1]):
      if(i != j):
        D[i,j] = 0
  return D

def traza(A):
  traza = 0
  for i in range(0,A.shape[0]):
    traza = traza + A[i,i]
  return traza

def transpuesta(A):
  T = np.zeros((A.shape[1],A.shape[0]))
  for i in range(0,T.shape[0]):
    for j in range(0, T.shape[1]):
      T[i,j] = A[j,i]
  return T

def esSimetrica(A):
  T = transpuesta(A)
  if(A.shape != T.shape): return False
  for i in range(0,A.shape[0]):
    for j in range(0, A.shape[1]):
      if(A[i,j] != T[i,j]): return False
  return True

def calcularAx(A,x):
  res = np.zeros(A.shape[0])
  for i in range(0, A.shape[0]):
    for j in range(0, A.shape[1]):
      res[i] = res[i] + A[i,j]*x[j]
  return res

def intercambiarFilas(A,i,j):
  filai = A[i].copy()
  filaj = A[j].copy()
  A[i] = filaj
  A[j] = filai
  return A

def sumar_fila_multiplo(A,i,j,s):
  A[i] = A[i] + (A[j]*s)
  return A

def esDiagonalmenteDominante(A):
  for i in range(A.shape[0]):
    absFila = 0
    absDiagonal = abs(A[i,i])
    for j in range(A.shape[1]):
      if(i != j):
        absFila = absFila + abs(A[i,j])
    if(absFila >= absDiagonal):
      return False
  return True

def matrizCirculante(v):
  A = np.zeros((v.shape[0],v.shape[0]))
  for i in range(0,v.shape[0]):
    for j in range(0, v.shape[0]):
      A[i,j] = v[(i + j) % v.shape[0]]
  return A

def matrizVandermonde(v):
  A = np.zeros((v.shape[0],v.shape[0]))
  for i in range(0, v.shape[0]):
    A[i] = v**i
  return A

def error(x, y):
    return abs(float(x) - float(y))

def error_relativo(x,y):
  if(x == 0): return 0.
  return abs(abs(float(x) - float(y)) / float(x))

def sonIguales(x,y,atol=1e-08):
    return np.allclose(error(x,y),0,atol=atol)

def matricesIguales(A, B, tol = np.finfo(np.double).eps * 2):
    if((len(A) != len(B)) | (len(A[0]) != len(B[0]))):
      raise Exception("Matrices have different dimension, can't compare equality.")

    for ra,rb in zip(A,B):
        for a,b in zip(ra,rb):
            if not sonIguales(a,b):
                return False
    return True

def filasIguales(A, B, tol = np.finfo(np.double).eps * 2):
  if(len(A) != len(B)):
    raise Exception("Matrices have different dimension, can't compare equality.")
  for a,b in zip(A,B):
    if not sonIguales(a,b):
                return False
  return True

def matMul(A,B):
    if(len(A[0]) != len(B)):
      raise Exception("Matrices dimensions don't match for multiplication")
    res = np.zeros((A.shape[0],B.shape[1]))
    for i in range(0,res.shape[1]):
      res[:,i] = calcularAx(A,B[:,i])
    return res

def rota(theta):
  return np.array([[np.cos(theta),-np.sin(theta)],[np.sin(theta),np.cos(theta)]])

def escala(s):
  return np.eye(len(s))*s

def rota_y_escala(theta,s):
  return matMul(escala(s),rota(theta))

def afin(theta,s,b):
  mat = rota_y_escala(theta,s)

  res = np.zeros((3,3))
  for i in range(2):
      for j in range(2):
          res[i][j] = mat[i][j]

  res[0][2] = b[0] # mejorable
  res[1][2] = b[1]
  res[2][2] = 1
  return res

def trans_afin(v , theta , s , b):
    matriz_afin = afin(theta , s , b)
    vec = [v[0], v[1], 1]
    resultado = calcularAx(matriz_afin, vec)
    return [resultado[0], resultado[1]]

def norma(x,p):
  if(p == 'inf'):
    maxim = -1
    for val in x:
      maxim = max(maxim,abs(val))
    return maxim
  sum = 0
  for i in range(0,x.size):
    sum = sum + abs(x[i])**p
  return sum**(1/p)

def normaliza(X,p):
  res = []
  for i in range(len(X)):
    res.append(X[i]/norma(X[i],p))
  return res

def normaExacta(A,p=[1,'inf']):
  norma = -1
  if p == 1:
    for col in range(A.shape[1]):
      sumCol = 0
      for fil in range(A.shape[0]):
        sumCol = sumCol + abs(A[fil,col])
      norma = max(norma,sumCol)
  if p == 'inf':
    for fil in range(A.shape[0]):
      sumFil = 0
      for col in range(A.shape[1]):
        sumFil = sumFil + abs(A[fil,col])
      norma = max(norma,sumFil)
  if norma == -1: return None
  return norma

def normaMatMC(A,q,p,Np):
  mc = np.random.rand(Np,A.shape[1])
  mc = normaliza(mc,p)
  normaMat = -1
  vec = []
  for x in mc:
    candidate = norma(calcularAx(A,x),q)
    if(candidate > normaMat):
      normaMat = candidate
      vec = x
  return [normaMat,vec]

def condMC(A,p,Np=10000):
  A_inv = np.linalg.inv(A)
  norma_A = normaMatMC(A,p,p,100000)
  norma_A_Inv = normaMatMC(A_inv,p,p,100000)
  return norma_A[0] * norma_A_Inv[0]

def condExacto(A,p):
  A_inv = np.linalg.inv(A)
  norma_A = normaExacta(A,p)
  norma_A_Inv = normaExacta(A_inv,p)
  return norma_A*norma_A_Inv

def calculaLU(A):
    cant_op = 0
    m=A.shape[0]
    n=A.shape[1]
    Ac = A.copy()
    if m!=n:
        print('Matriz no cuadrada')
        return None

    for i in range(m):
        for j in range(i+1,m):
            if(Ac[i,i] == 0):
              return None, None, 0
            pivot = Ac[j,i]/Ac[i,i]
            for k in range(i,n):
                Ac[j,k] = Ac[j,k]-pivot*Ac[i,k]
                cant_op = cant_op + 2
            Ac[j,i] = pivot

    U = np.zeros((m,n))
    L = np.eye(m)
    zerorow = np.zeros(U.shape[1])
    for i in range(m):
        for j in range(n):
            if(i<=j):
                U[i,j] = Ac[i,j]
            if(i>j):
                L[i,j] = Ac[i,j]
        if(filasIguales(zerorow,U[i,:])): return None, None, 0
    return L, U, cant_op

def res_tri(L,b,inferior=True):
  res = np.zeros(b.shape[0])
  if(inferior):
    res[0] = b[0]/L[0,0]
    for i in range(1,L.shape[0]):
      xb = res*L[i,:]
      sum = 0
      for j in range(xb.shape[0]):
         sum = sum + xb[j]
      res[i]=(b[i]-sum)/L[i,i]
  if(not inferior):
    n = L.shape[0]
    res[n-1] = b[n-1]/L[n-1,n-1]
    for i in reversed(range(n-1)):
      xb = res*L[i,:]
      sum = 0
      for j in range(xb.shape[0]):
         sum = sum + xb[j]
      res[i]=(b[i]-sum)/L[i,i]
  return res

def inversa(A):
  L,U,_ = calculaLU(A)
  if (L is None and U is None): return None
  I = np.eye(L.shape[0])

  x = np.zeros_like(L)
  for i in range(x.shape[0]):
    x[:,i] = res_tri(L,I[:,i])
  res = np.zeros_like(A)
  for i in range(res.shape[1]):
    res[:,i] = res_tri(U,x[:,i],inferior=False)
  return res

def calculaLDV(A):
  L, U, nops1 = calculaLU(A)
  if(U is None): return None,None,None,None
  V_T, D, nops2 = calculaLU(transpuesta(U))
  V = transpuesta(V_T)
  return L, D, V, nops1 + nops2

def esSDP(A,atol=1e-10):
  L,D,V,_=calculaLDV(A)
  if(L is None): return False
  if(not matricesIguales(transpuesta(L),V,tol=atol)): return False
  for i in range(D.shape[0]):
    if(D[i,i] <= 0): return False
  return True

def QR_con_GS(A, tol=1e-12,retorna_nops=False):
    nops = 0
    Q = np.zeros(A.shape)
    R = np.zeros(A.shape)

    R[0,0] = norma(A[:,0],2)
    Q[:,0] = A[:,0] / R[0,0]

    for j in range(1,A.shape[0]):
      Q[:,j] = A[:,j]
      for k in range(0, j):
        R[k,j] = np.dot(Q[:,k],Q[:,j])
        Q[:,j] = Q[:,j] - R[k,j]*Q[:,k]
        nops = nops + 4*A.shape[0]
      R[j,j] = norma(Q[:,j],2)
      Q[:,j] = Q[:,j]/R[j,j]
      nops = nops + A.shape[0]

    if(retorna_nops):
      return Q,R,nops
    else:
      return Q,R

def metpot2k(A, tol=1e-15, max_iter=1000):
    """
    Calcula el autovalor dominante (de mayor magnitud) y su autovector
    correspondiente usando el método de la potencia cuadrado (iterando con A^2).

    Argumentos:
    A (np.array): La matriz de entrada (n x n).
    tol (float): Tolerancia para la convergencia.
    max_iter (int/float): Número máximo de iteraciones.

    Devuelve:
    (v, l, k):
      v: El autovector dominante (vector columna n x 1).
      l: El autovalor dominante (escalar).
      k: El número de iteraciones realizadas.
    """
    n = A.shape[0]
    v = np.random.rand(n, 1)
    v = v / norma(v,2)

    l_prev = 0.0

    max_iter = int(max_iter)

    for k in range(max_iter):
        w = matMul(A,(matMul(A,v)))
        norma_w = norma(w,2)
        if norma_w < tol:
            return v, 0.0, k

        v_nuevo = w / norma_w
        l_nuevo = matMul(transpuesta(v_nuevo),matMul(A,v_nuevo))[0, 0]

        if np.abs(l_nuevo - l_prev) < tol:
            return v_nuevo, l_nuevo, k

        v = v_nuevo
        l_prev = l_nuevo

    print(f"El método no convergió después de {max_iter} iteraciones.")
    return v, l_nuevo, max_iter

def diagRH(A, tol = 1e-15, K = 1000):

    n = A.shape[0]
    (autovector,autovalor,eps) = metpot2k(A,tol,K)
    I = np.eye(A.shape[0])
    e_i = np.zeros_like(autovector)
    e_i[0] = 1

    u = (e_i - autovector).reshape(-1,1)
    u_t = u.T
    u_norma = norma(u,2)
    H_v = I - 2*((matMul(u,u_t))/(u_norma**2))

    if n == 2:
        S = H_v
        D = matMul(H_v,matMul(A,transpuesta(H_v)))

    else:

        B = matMul(H_v,matMul(A,transpuesta(H_v)))
        A_nuevo = B[1:,1:]

        (S_nuevo, D_nuevo) = diagRH(A_nuevo,tol,K)

        D = np.zeros(B.shape)
        D[0][0] = autovalor
        D[1:,1:] = D_nuevo

        S_extra = np.zeros(B.shape)
        S_extra[0][0] = 1
        S_extra[1:,1:] = S_nuevo

        S = matMul(H_v,S_extra)


    return (S,D)

def transiciones_al_azar_continuas(n):
    """
    n la cantidad de filas (columnas) de la matriz de transición.
    Retorna matriz T de n x n normalizada por columnas, y con entradas al azar en el intervalo [0,1]
    """
    T = np.random.rand(n,n)
    for i in range(n):
      T[:,i] = T[:,i]/norma(T[:,i],1)
    return T

def transiciones_al_azar_uniformes(n,thres):
    """
    n la cantidad de filas (columnas) de la matriz de transición.
    thres probabilidad de que una entrada sea distinta de cero.
    Retorna matriz T de n x n normalizada por columnas.
    El elemento i,j es distinto de cero si el número generado al azar para i,j es menor o igual a thres.
    Todos los elementos de la columna $j$ son iguales
    (a 1 sobre el número de elementos distintos de cero en la columna).
    """
    T = (np.random.rand(n,n) < 0.3).astype(float)
    for i in range(n):
      norm=norma(T[:,i],1)
      if(norm != 0):
          T[:,i] = T[:,i]/norm
      else:
          T[np.random.randint(0,n),i] = 1.
    return T

def nucleo(A,tol=1e-15):
    """
    A una matriz de m x n
    tol la tolerancia para asumir que un vector esta en el nucleo.
    Calcula el nucleo de la matriz A diagonalizando la matriz traspuesta(A) * A (* la multiplicacion matricial), usando el medodo diagRH. El nucleo corresponde a los autovectores de autovalor con modulo <= tol.
    Retorna los autovectores en cuestion, como una matriz de n x k, con k el numero de autovectores en el nucleo.
    """
    diag =  diagRH(matMul(transpuesta(A),A),tol,1000)
    mascara_cero = np.isclose(np.diag(diag[1]), 0, atol=tol)
    return (diag[0])[:, mascara_cero]


def crea_rala(listado,m_filas,n_columnas,tol=1e-15):
    """
    Recibe una lista listado, con tres elementos: lista con indices i, lista con indices j, y lista con valores A_ij de la matriz A. Tambien las dimensiones de la matriz a traves de m_filas y n_columnas. Los elementos menores a tol se descartan.
    Idealmente, el listado debe incluir unicamente posiciones correspondientes a valores distintos de cero. Retorna una lista con:
    - Diccionario {(i,j):A_ij} que representa los elementos no nulos de la matriz A. Los elementos con modulo menor a tol deben descartarse por default.
    - Tupla (m_filas,n_columnas) que permita conocer las dimensiones de la matriz.
    """
    matriz = {}
    if(len(listado) != 0):
      for i,j,aij in zip(listado[0],listado[1],listado[2]):
        if(abs(aij) >= tol):
            matriz[(i,j)] = aij
    return matriz, (m_filas, n_columnas)

def multiplica_rala_vector(A,v):
    """
    Recibe una matriz rala creada con crea_rala y un vector v.
    Retorna un vector w resultado de multiplicar A con v
    """
    b = np.zeros_like(v)

    for elem in A[0].keys():
         b[elem[0]] = b[elem[0]] + A[0][elem]*v[elem[1]]
    return b

def es_markov(T,tol=1e-6):
    """
    T una matriz cuadrada.
    tol la tolerancia para asumir que una suma es igual a 1.
    Retorna True si T es una matriz de transición de Markov (entradas no negativas y columnas que suman 1 dentro de la tolerancia), False en caso contrario.
    """
    n = T.shape[0]
    for i in range(n):
        for j in range(n):
            if T[i,j]<0:
                return False
    for j in range(n):
        suma_columna = sum(T[:,j])
        if np.abs(suma_columna - 1) > tol:
            return False
    return True

def es_markov_uniforme(T,thres=1e-6):
    """
    T una matriz cuadrada.
    thres la tolerancia para asumir que una entrada es igual a cero.
    Retorna True si T es una matriz de transición de Markov uniforme (entradas iguales a cero o iguales entre si en cada columna, y columnas que suman 1 dentro de la tolerancia), False en caso contrario.
    """
    if not es_markov(T,thres):
        return False
    # cada columna debe tener entradas iguales entre si o iguales a cero
    m = T.shape[1]
    for j in range(m):
        non_zero = T[:,j][T[:,j] > thres]
        # all close
        close = all(np.abs(non_zero - non_zero[0]) < thres)
        if not close:
            return False
    return True

def esNucleo(A,S,tol=1e-5):
    """
    A una matriz m x n
    S una matriz n x k
    tol la tolerancia para asumir que un vector esta en el nucleo.
    Retorna True si las columnas de S estan en el nucleo de A (es decir, A*S = 0. Esto no chequea si es todo el nucleo
    """
    for col in S.T:
        res = A @ col
        if not np.allclose(res,np.zeros(A.shape[0]), atol=tol):
            return False
    return True

def svd_reducida(A, k="max", tol=1e-15):
    """
    A la matriz de interes (de m x n)
    k el numero de valores singulares (y vectores) a retener.
    tol la tolerancia para considerar un valor singular igual a cero
    Retorna hatU (matriz de m x k), hatSig (matriz diagonal de k x k) y hatV (matriz de n x k)
    """
    m, n = A.shape

    if m < n:
        B = matMul(A, transpuesta(A))
        diagonalizacion = diagRH(B, tol)
        U = diagonalizacion[0]
        D = diagonalizacion[1]

        autovalores_orig = np.diag(D)
        indices_ordenados = np.argsort(autovalores_orig)[::-1]
        autovalores_ordenados = autovalores_orig[indices_ordenados]
        U_ordenado = U[:, indices_ordenados]

        autovalores_filtrados = autovalores_ordenados[autovalores_ordenados >= tol]
        valores_singulares = np.sqrt(autovalores_filtrados)
        r = len(valores_singulares)

        if k == "max":
            k_eff = r
        else:
            k_eff = min(int(k), r)

        hatS = np.diag(valores_singulares[:k_eff])
        hatU = U_ordenado[:, :k_eff]

        hatV = np.zeros((A.shape[1], k_eff))
        B_v = matMul(transpuesta(A), hatU)

        for i in range(k_eff):
            sigma_i = hatS[i, i]
            if sigma_i >= tol:
                hatV[:, i] = B_v[:, i] / sigma_i

    else: # (m >= n)
        B = matMul(transpuesta(A), A)
        diagonalizacion = diagRH(B, tol)
        V = diagonalizacion[0]
        D = diagonalizacion[1]

        autovalores_orig = np.diag(D)
        indices_ordenados = np.argsort(autovalores_orig)[::-1]
        autovalores_ordenados = autovalores_orig[indices_ordenados]
        V_ordenado = V[:, indices_ordenados]

        autovalores_filtrados = autovalores_ordenados[autovalores_ordenados >= tol]
        valores_singulares = np.sqrt(autovalores_filtrados)
        r = len(valores_singulares)

        if k == "max":
            k_eff = r
        else:
            k_eff = min(int(k), r)

        hatS = np.diag(valores_singulares[:k_eff])
        hatV = V_ordenado[:, :k_eff]

        hatU = np.zeros((A.shape[0], k_eff))
        B_u = matMul(A, hatV)

        for i in range(k_eff):
            sigma_i = hatS[i, i]
            if sigma_i >= tol:
                hatU[:, i] = B_u[:, i] / sigma_i

    return hatU, hatS, hatV